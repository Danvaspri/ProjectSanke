<!DOCTYPE html>
<html>

<head>
    <title>SANKE</title>
</head>

<body>
    <canvas id="canvas" width="300" height="300"></canvas>
    <script src="web-lib/processing.js"></script>
    <script src="web-lib/functional-light.js"></script>
    <script>
        let { append, cons, first, isEmpty, isList, length, rest } = functionalLight;

        //crea un objeto nuevo a partir de un objeto y un atributo
        function make(data, attribute) {
            return Object.assign({}, data, attribute);
        }

        //retorna un numero al azar entre 0 y 20
        function random() {
            return Math.round(Math.random() * 20)
        }

        //recibe una lista y retorna una lista igual sin el ultimo valor
        function listMinOne(list) {
            if (length(list) == 1) {
                return [];
            }
            else {
                return cons(first(list), listMinOne(rest(list)));
            }
        }

        //retorna true si el elemento esta dentro de la lista (solo recibe objetos)
        function inList(element, list) {
            if (isEmpty(list)) {
                return false
            }
            if (element.x == first(list).x && element.y == first(list).y) {
                return true
            }
            return inList(element, rest(list))
        }

        //si el primer objeto es igual a alguno de la lista, termina el juego (la serpiente se comio)
        function ateSelf(world) {
            if (inList(world.snake[0], rest(world.snake))) {
                make(world, { gameover: true })
                return world;
            }
        }

        //si la cabeza se sale del mapa, termina el juego
        function outTheMap(world) {
            if ((world.snake[0].x > 10) && (world.snake[0].y > 10)          // cambiar valores segun los del canvas
                && (world.snake[0].x <= 10) && (world.snake[0].y <= 10)) {
                make(world, { gameover: true })
                return world;
            }
        }

        //if world.pause = true, returns same world over and over (pauses).
        function pause(world) {
            if (world.pause == true) {
                return world
            }
        }

        //retorna true si la posicion de la cabeza es igual a la de la comida
        function gotFood(world) {
            return (world.snake[0].x == world.foodPos.x && world.snake[0].y == world.foodPos.y);
        }

        function movement(world) {
            switch (world.direction) {
                case "up":
                    if ((gotFood(world))) {
                        return make(world, {
                            snake: cons(make(world.snake[0], { y: world.snake[0].y - 1 }), world.snake),
                            foodPos: { x: random(), y: random() },
                        });
                        break;
                    }
                    else {
                        return make(world, {
                            snake: cons(make(world.snake[0], { y: world.snake[0].y - 1 }),
                                listMinOne(world.snake))
                        });
                        break;
                    }
                case "down":
                    if ((gotFood(world))) {
                        return make(world, {
                            snake: cons(make(world.snake[0], { y: world.snake[0].y + 1 }), world.snake),
                            foodPos: { x: random(), y: random() },
                        });
                        break;
                    }
                    else {
                        return make(world, {
                            snake: cons(make(world.snake[0], { y: world.snake[0].y + 1 }),
                                listMinOne(world.snake))
                        });
                        break;
                    }
                case "left":
                    if ((gotFood(world))) {
                        return make(world, {
                            snake: cons(make(world.snake[0], { x: world.snake[0].x - 1 }), world.snake),
                            foodPos: { x: random(), y: random() },
                        });
                        break;
                    }
                    else {
                        return make(world, {
                            snake: cons(make(world.snake[0], { x: world.snake[0].x - 1 }),
                                listMinOne(world.snake))
                        });
                        break;
                    }
                case "right":
                    if ((gotFood(world))) {
                        return make(world, {
                            snake: cons(make(world.snake[0], { x: world.snake[0].x + 1 }), world.snake),
                            foodPos: { x: random(), y: random() },
                        });
                        break;
                    }
                    else {
                        return make(world, {
                            snake: cons(make(world.snake[0], { x: world.snake[0].x + 1 }),
                                listMinOne(world.snake))
                        });
                        break;
                    }
                default:
                    return make(world, {});
            }
        }

        //esta funcion debe verificar que la comida no aparezca dentro de la serpiente
        function foodSpawn(object) {

        }


        //funcion principal, no se que hace pero es importante
        function sketchProc(processing) {

            processing.setup = function () {
                processing.frameRate(7);
                processing.size(40 * 20, 25 * 20);
                processing.background(0, 0, 0);
                processing.state = {
                    direction: "right", foodPos: { x: random(), y: random() },
                    snake: [{ x: 3, y: 1 }, { x: 2, y: 1 }, { x: 1, y: 1 }, { x: 0, y: 1 }],
                    pause: false, score: 0, gameover: false
                }
            }

            //funcion que recibe teclas como entrada
            processing.onKeyEvent = function (world, keyCode) {
                switch (keyCode) {
                    case processing.UP:
                        if (world.direction == "down") {
                            return world
                        }
                        else {
                            //para evitar el error de morir, se agrega movimiento de un cuadro al pulsar la tecla
                            //en lugar de solo cambiar direccion 
                            if ((gotFood(world))) {
                                return make(world, {
                                    snake: cons(make(world.snake[0], { y: world.snake[0].y - 1 }), world.snake),
                                    foodPos: { x: random(), y: random() },
                                    direction: "up"
                                });
                                break;
                            }
                            else {
                                return make(world, {
                                    snake: cons(make(world.snake[0], { y: world.snake[0].y - 1 }),
                                        listMinOne(world.snake)),
                                    direction: "up"
                                });
                                break;
                            }
                        }
                    case processing.DOWN:
                        if (world.direction == "up") {
                            return world
                        }
                        else {
                            return make(world, { direction: "down" });
                        }
                    case processing.LEFT:
                        if (world.direction == "right") {
                            return world
                        }
                        else {
                            return make(world, { direction: "left" });
                        }
                    case processing.RIGHT:
                        if (world.direction == "left") {
                            return world
                        }
                        else {
                            return make(world, { direction: "right" });
                        }
                    case 80: //la P es la letra 80
                        if (world.pause == false) {
                            return make(world, { pause: true })
                            break;
                        }
                        else {
                            return make(world, { pause: false })
                            break;
                        }
                    default:
                        console.log(keyCode);
                        return make(world, {});
                }
            }

            //funcion que se repite varias veces
            processing.onTic = function (world) {
                if (inList(world.snake[0], rest(world.snake))) {
                    return make(world, { gameover: true });
                }
                if ((world.snake[0].x >= 40) || (world.snake[0].y >= 25)          // cambiar valores segun los del canvas
                    || (world.snake[0].x < 0) || (world.snake[0].y < 0)) {
                    return make(world, { gameover: true });
                }
                if (world.pause == true) {
                    return world
                }
                /*ateSelf(world);
                outTheMap(world);  //estas funciones estan definidas arriba pero al llamarse, no funcionan
                pause(world);*/
                return movement(world);
            }

            //funcion que dibuja cuadrados segun el largo de la serpiente, pinta la sepiente
            function snakeLength(list) {
                if (length(list) == 1) {
                    processing.rect(first(list).x * 20, first(list).y * 20, 20, 20)
                }
                else {
                    processing.rect(first(list).x * 20, first(list).y * 20, 20, 20)
                    snakeLength(rest(list))
                }
            }
            //funcion que pinta el juego
            processing.drawGame = function (world) {
                processing.background(100, 100, 250);
                processing.fill(0, 255, 0)
                processing.rect(world.foodPos.x * 20, world.foodPos.y * 20, 20, 20)
                processing.fill(200, 200, 200);
                snakeLength(world.snake)
                processing.fill(255, 0, 0);
                if (world.gameover == true) {
                    processing.textFont(processing.PFont, 50);
                    processing.text("GAME OVER", 50, 210);
                }
                if (world.pause == true) {
                    processing.textFont(processing.PFont, 50);
                    processing.text("PAUSED", 105, 210);
                }
                processing.textFont(processing.PFont, 20);
                processing.text("SCORE: " + world.score, 20, 390);
            }

            processing.draw = function () {
                processing.drawGame(processing.state);
                processing.state = processing.onTic(processing.state);
            };

            processing.keyPressed = function () {
                processing.state = processing.onKeyEvent(processing.state, processing.keyCode);
            }
        }
        var canvas = document.getElementById("canvas");

        var processingInstance = new Processing(canvas, sketchProc);
    </script>
</body>

</html>
