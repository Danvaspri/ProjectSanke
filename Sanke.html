<!DOCTYPE html>
<html>

<head>
    <title>SANKE</title>
</head>

<body>
    <canvas id="canvas" width="300" height="300"></canvas>
    <script src="web-lib/processing.js"></script>
    <script src="web-lib/functional-light.js"></script>
    <script>
        let { append, cons, first, isEmpty, isList, length, rest } = functionalLight;

        const size = 20
        const canvasSize = 25
        const easy = 2
        const medium = easy * 2
        const hard = easy * 3



        //Creates a new object with another object and modifying/adding a given attribute to it.
        function make(data, attribute) {
            return Object.assign({}, data, attribute);
        }

        //Returns a random number between 0 and canvasSize-1.
        function random() {
            return Math.round(Math.random() * (canvasSize - 1))
        }

        //Returns same list without last element.
        function listMinOne(list) {
            if (length(list) == 1) {
                return [];
            }
            else {
                return cons(first(list), listMinOne(rest(list)));
            }
        }

        //Checks if element is inside list.
        function inList(element, list) {
            if (isEmpty(list)) {
                return false
            }
            if (element.x == first(list).x && element.y == first(list).y) {
                return true
            }
            return inList(element, rest(list))
        }

        //Checks if head's position equals any of the rest of the body.
        function ateSelf(world) {
            if (inList(world.snake[0], rest(world.snake))) {
                return true;
            }
            return false;
        }

        //Checks if snake's head got out of the canvas.
        function outTheMap(world) {
            if ((world.snake[0].x >= canvasSize) || (world.snake[0].y >= canvasSize) || (world.snake[0].x < 0) || (world.snake[0].y < 0)) {
                return true;
            }
            return false
        }

        //If world.pause == true, returns same world.
        function pause(world) {
            if (world.pause == true) {
                return world
            }
        }

        //Returns true if food's position is equal to that of the snake's head.
        function gotFood(world) {

            if (world.snake[0].x == world.foodPos.x && world.snake[0].y == world.foodPos.y) {
                return make(world, { snake: growSnake(world), foodPos: foodSpawn(world) })
            }
            return world;
        }


        //Adds one square behind the last of the snake.
        function growSnake(world) {
            const len = length(world.snake)
            if (world.snake[len - 2].x > world.snake[len - 1].x) {
                return append(world.snake, { x: world.snake[len - 1].x - 1, y: world.snake[len - 1].y })
            }
            if (world.snake[len - 2].x < world.snake[len - 1].x) {
                return append(world.snake, { x: world.snake[len - 1].x + 1, y: world.snake[len - 1].y })
            }
            if (world.snake[len - 2].y < world.snake[len - 1].y) {
                return append(world.snake, { y: world.snake[len - 1].y + 1, x: world.snake[len - 1].x })
            }
            if (world.snake[len - 2].y > world.snake[len - 1].y) {
                return append(world.snake, { y: world.snake[len - 1].y - 1, x: world.snake[len - 1].x })
            }
        }


        //Moves the snake depending on world.direction.
        function movement(world) {
            switch (world.direction) {
                case "up":
                    return make(world,
                        { snake: cons(make(world.snake[0], { y: world.snake[0].y - 1 }), listMinOne(world.snake)) });
                    break;
                case "down":
                    return make(world,
                        { snake: cons(make(world.snake[0], { y: world.snake[0].y + 1 }), listMinOne(world.snake)) });
                    break;
                case "left":
                    return make(world, {
                        snake: cons(make(world.snake[0], { x: world.snake[0].x - 1 }), listMinOne(world.snake))
                    });
                    break;
                case "right":
                    return make(world, {
                        snake: cons(make(world.snake[0], { x: world.snake[0].x + 1 }), listMinOne(world.snake))
                    });
                    break;
                default:
                    return make(world, {});
            }
        }

        //Makes sure food never spawns under the snake.
        function foodSpawn(world) {
            const val = { x: random(), y: random() }
            if (inList(val, world.snake)) {
                return foodSpawn(world)
            }
            return val
        }



        function sketchProc(processing) {

            const body = processing.loadImage("images/snake.jpg")
            const headDown = processing.loadImage("images/headDown.jpg")
            const headRight = processing.loadImage("images/headRight.jpg")
            const headUp = processing.loadImage("images/headUp.jpg")
            const headleft = processing.loadImage("images/headLeft.jpg")

            processing.setup = function () {
                processing.size(canvasSize * size, canvasSize * size);
                processing.background(0, 0, 0);
                processing.state = {
                    direction: "right",
                    canPress: true,
                    foodPos: { x: random(), y: random() },
                    frameRate: medium,
                    snake: [{ x: 3, y: 1 }, { x: 2, y: 1 }, { x: 1, y: 1 }],
                    pause: false,
                    playing: false,
                    gameover: false
                }

            }

            //Modifies direction and pause atributes of the world given a right keyCode.
            processing.onKeyEvent = function (world, keyCode) {
                switch (keyCode) {
                    case processing.UP:
                        if (world.direction == "down") {
                            return world
                        }
                        else {
                            return make(world, { direction: "up" });
                        }
                    case processing.DOWN:
                        if (world.direction == "up") {
                            return world
                        }
                        else {
                            return make(world, { direction: "down" });
                        }
                    case processing.LEFT:
                        if (world.direction == "right") {
                            return world
                        }
                        else {
                            return make(world, { direction: "left" });
                        }
                    case processing.RIGHT:
                        if (world.direction == "left") {
                            return world
                        }
                        else {
                            return make(world, { direction: "right" });
                        }
                    case 80: //la P es la letra 80
                        if (world.pause == false) {
                            return make(world, { pause: true, canPress: true })
                            break;
                        }
                        else {
                            return make(world, { pause: false, canPress: true })
                            break;
                        }
                    default:
                        console.log(keyCode);
                        return make(world, {});
                }
            }

            //Executes itself every frameRate.
            processing.onTic = function (world) {
                processing.frameRate(world.frameRate);

                //If pause is set to true, the game is over or is not playing, returns same world constantly.
                if (world.pause || world.gameover || !world.playing) {
                    return make(world)
                }

                //If player ate its self or got out of the canvas, gameover is set to true.
                if (ateSelf(world) || outTheMap(movement(world))) {
                    return make(world, { gameover: true, canPress: false });
                }

                return make(gotFood(movement(world)), { canPress: true });
            }

            /**
             * Executes the function 'image' from processing as many times as the list length
             * @param {list} list
             * @return {undefined}
             * */
            function drawSnakeBody(list) {
                if (length(list) == 1) {
                    processing.image(body, first(list).x * size, first(list).y * size)
                }
                else {
                    processing.image(body, first(list).x * size, first(list).y * size)
                    drawSnakeBody(rest(list))
                }
            }
            /**
             * Executes the function 'image' from processing to draw an image based on the 'direction' atributte
             * @param {object} world 
             * @return {undefined}
             * */
            function drawSnakeHead(world) {
                switch (world.direction) {
                    case "up":
                        processing.image(headUp, world.snake[0].x * size, world.snake[0].y * size)
                        break;
                    case "down":
                        processing.image(headDown, world.snake[0].x * size, world.snake[0].y * size)
                        break;
                    case "left":
                        processing.image(headleft, world.snake[0].x * size, world.snake[0].y * size)
                        break;
                    case "right":
                        processing.image(headRight, world.snake[0].x * size, world.snake[0].y * size)
                        break;
                }
            }

             /**
            * if world.gameover equals true returns the game over message
            * @param {object} world
            * @returns {undefined}
            */
            function gameOver(world) {
                if (world.gameover == true) {
                    processing.textFont(processing.PFont, 50);
                    processing.text("GAME OVER", 50, 210);
                }
            }
            function pause(world){
                if (world.pause == true) {
                    processing.textFont(processing.PFont, 50);
                    processing.text("PAUSED", 105, 210);
                }  
            }

            //Draws a world.
            processing.drawGame = function (world) {
                processing.background(100, 100, 250);
                processing.fill(0, 255, 0)
                processing.rect(world.foodPos.x * 20, world.foodPos.y * 20, 20, 20)
                processing.fill(200, 200, 200);
                drawSnakeBody(rest(world.snake))
                drawSnakeHead(world)
                processing.fill(255, 0, 0);
                gameOver(world);
                pause(world);
                if (world.playing == false) {
                    processing.textFont(processing.PFont, 50);
                    processing.text("CLICK TO START", canvasSize, (canvasSize * 20) / 2);

                }
                processing.textFont(processing.PFont, 20);
                processing.text("SCORE: " + (length(world.snake) - 3), 20, 390);
            }


            //This function is called repeatedly, calls drawgame and onTic.
            processing.draw = function () {
                processing.state = processing.onTic(processing.state);
                processing.drawGame(processing.state);
            };


            /*Changes framerate if world is not currently playing.
            This makes it necessary for difficult to be set before starting to play.*/
            processing.changeFrameRate = function (frames) {
                if (!processing.state.playing) {
                    processing.state = make(processing.state, { frameRate: frames });
                }
            }

            /**
            * Re asing the initial world to processing.state
             * @returns {object}
             * */
            processing.restart = function () {
                processing.state = {
                    direction: "right",
                    canPress: true,
                    foodPos: { x: random(), y: random() },
                    frameRate: medium,
                    snake: [{ x: 3, y: 1 }, { x: 2, y: 1 }, { x: 1, y: 1 }],
                    pause: false,
                    playing: false,
                    gameover: false
                }
            }


            /**
            * Changes the playing state from false to true if event.action is 'click'
            @param {object} world
            @param {object} event
            @returns {object}
            @example make(world, { playing: true })
            */
            processing.onMouseEvent = function (world, event) {
                if (event.action === 'click') {
                    return make(world, { playing: true })
                }
                return world
            }

            //Executes when key is pressed.
            processing.keyPressed = function () {
                if (processing.state.canPress) {
                    processing.state = processing.onKeyEvent(make(processing.state, { canPress: false }), processing.keyCode);
                }
            }


            processing.mouseClicked = function () {
                processing.state = processing.onMouseEvent(processing.state,
                    { action: "click" });
            }

        }

        var canvas = document.getElementById("canvas");
        var processingInstance = new Processing(canvas, sketchProc);

    </script>
    <br>
    <button class="restartButton" onClick="processingInstance.restart()">
        RESTART
    </button>
    <button class="restartButton" onClick="processingInstance.changeFrameRate(easy)">
        EASY
    </button>
    <button class="restartButton" onClick="processingInstance.changeFrameRate(medium)">
        MEDIUM
    </button>
    <button class="restartButton" onClick="processingInstance.changeFrameRate(hard)">
        HARD
    </button>
</body>

</html>